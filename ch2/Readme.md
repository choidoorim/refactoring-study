# Ch2 - 리팩터링 원칙
## 2.1 리팩터링 정의
- 리팩터링은 기능에는 영향을 미치지 않고 코드의 질을 높이는 것이다. 즉, 리팩터링 전과 후의 코드가 똑같이 동작 해야한다.


- 명사로는 **"코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법"** 이며, 동사로는 **"여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다"** 이다.
  - 명사: 함수 추출하기, 조건부 로직을 다형성으로 바꾸기 등
  

- 한 번에 바꿀 수 있는 작업을 수많은 단계로 잘게 나눠서 작업한다. 이를 통해 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는 데 많은 시간을 소요하지 않아도 된다.

## 2.2 두 개의 모자
- 기능 추가라는 모자와 리팩터링이라는 모자 2개를 바꿔쓰면서 개발을 해야 한다.


- 기능 추가는 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다.


- 리팩터링은 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.


## 2.3 리팩터링 하는 이유
- 중복 코드 제거는 설계 개선 작업의 중요한 요소이다. 시스템이 빨라지거나 용량이나 속도에 영향을 주는 경우는 별로 없다. 하지만 수정하는 데 드는 노력은 크게 달라지게 된다.
즉, 사람이 **소프트웨어를 이햐하는데 소요하는 시간을 줄일 수 있기에** 생산성을 높일 수 있다.


- 프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다' 라고 가정하던 점들이 분명히 드러나고, **버그를 지나칠 수 없을 정도까지 명확**해지게 된다.


- 리팩터링을 하면 프로그래밍 속도를 높일 수 있다. 리팩터링에 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수도 있다.
하지만 리팩터링 되지 않은 시스템일 경우 커질 수록 기능을 추가하는 데 오래 걸린다. 즉, 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다.

## 2.4 언제 리팩터링해야 할까?
### 3 의 법칙
1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생긴다면), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

즉, 스트라이크 3 번이면 리팩터링해야 한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
복사 붙여넣는 방식으로 계속 처리하게 된다면 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다.
이럴 때 **"함수 매개변수화"** 를 한다.

우선 한 곳으로 합치면 버그를 잡기도 훨씬 편하고, 오류를 크게 줄일 수 있다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
조건부 로직의 구조가 이상하지 않은지, 함수 이름이 이상해서 하는 일을 파악하는 데 시간이 오래걸리지는 않은지 살펴봐야 한다.
어떤 역할은 하는지 이해되게 변수를 만들고, 긴 함수는 잘게 나눠야 한다.

### 쓰레기 줍기 리팩터링
간단히 수정할 수 있는 것은 즉시 수정하고, 시간이 조금 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 마무리 한 뒤 처리한다.
이것이 **쓰레기 줍기 리팩터링** 이다.

### 계획된 리팩터링과 수시로 하는 리팩터링
- 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다.


- 새 기능을 추가하기 쉽도록 코드를 수정하는 것이 기능을 가장 빠르게 추가하는 방법이다.


- 계획된 리팩터링은 팀 전체의 효율을 떨어트릴수도 있기 때문에, 리팩터링은 드러나지 않게 기회가 될 때마다 해야 한다.

### 오래 걸리는 리팩터링
- 오래 걸리는 리팩터링이라면 몇 주에 걸쳐 조금식 해결해가는 편이 효과적일 때가 많다.

### 코드 리뷰에 리팩터링 활용하기
- 코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.


- 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다. 코드리뷰를 하면서 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.


- 글쓴이의 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것이라고 한다. 이렇게 하는 것이 짝 프로그래밍이다.

### 리팩터링을 하지 말아야 할 때
- 리팩터링보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.

## 2.5 리팩터링 시 고려할 
### 새 기능 개발속도 저하
- 리팩토링은 새 기능을 개발하는 속도가 느려진다고 생각하지만, 궁극적인 목적은 개발 속도를 높여서 **더 적은 노력으로
더 많은 가치를 창출**하는 것이다.


- 리팩터링은 코드를 이쁘게 꾸미는 것 보다, 오로지 개발기간/기능 추가/버그수정시간을 단축시키는 경제적인 이유로 하는 것이다.

### 코드 소유자
- 함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있다. 이렇게 코드 소유권이 나눠져 있다면 리팩터링에 방해가 된다.


- 코드 소유자가 달라도 기존 함수를 그대로 유지하고 함수 본문에서 새 함수를 호출하도록 수정하면 클라이언트에 영향을 주지 않고 리팩터링이 가능하다.


### 브랜치
- 기존 브랜치를 사용하는 방식은 각자 맡은 일들을 브랜치를 생성해서 작업하고, 완료되면 마스터 브랜치에 합치는 방식이다.
하지만 이 방식은 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 

  
- 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 머지는 기하급수적으로 복잡해진다.
이 때문에 브랜치의 통합주기를 매우 짧게 가져가야 한다. 그리고 이 방식을 지속적 통합(CI), 또는 트렁크 기반 개발(TBD) 라고 한다.


- **CI(Continuous)** : 모든 팀원이 하루에 최소 한 번은 마스터와 통합해야 한다. 따라서 다른 브랜치들과의 차이를 크게 줄일 수 있다.
리팩토링을 하다보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 있기 때문에 리팩터링과 궁합이 아주 좋다. 
- 익스트림 프로그래밍 : ```CI + Refactoring```


### 테스팅
- 리팩토링은 겉보기 동작은 똑같이 유지됩니다. 동작에 문제가 없어야 하며, 실수하더라도 재빨리 잡아야하기 때문에 **반드시 자가 테스트 코드를 마련**해야 합니다.


- 테스트는 리팩토링에도 상당한 도움을 주지만, 새 기능 추가도 훨씬 한전하게 진행할 수 있도록 도와준다.


- 테스트는 통합 과정에서 발생하는 충돌을 잡을 수 있기에 CI 와도 밀접하게 연관된다. CI 에 통합된 테스트는 지속적 배포(Continuous Delivery) 의 핵심이기도 하다.


### 레거시 코드(기능이 정상적이지 않고, 테스트가 힘들거나 난해한 코드를 뜻함)
- 레거시 시스템을 파악할 때 리팩터링이 굉장이 도움이 된다. 기능과 다른 함수명을 바로 잡고 어설픈 프로그램 구문을 바르게 잡을 수도 있다.
하지만 대부분의 레거시 코드에는 테스트가 없다. 이럴 경우 대규모 레거시 시스템일 수록 리팩터링을 위해 당연히 **테스트를 보강**해야 한다.


- 레거시 코드는 테스트를 추가하기도 상당히 힘들고, 테스트 없이 리팩터링이 진행될 수밖에 없는 경우가 있다. 이런 경우 상당히 위험하지만 문제를 해결하기 위해서는 감내해야 한다.
따라서 초기부터 테스트 코드를 작성해나가는 것이 중요하다.


- 레거시를 리팩토링할 때 관련된 것들끼리 나눠서 공략하는 것이 좋다. 또한 코드를 훑고 넘어갈 때마다 조금이라도 코드를 개선하려고 노력해야 한다.

### 데이터베이스
- 다른 리팩터링과 동일하게 데이터베이스도 전체 변경과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.
그리고 여러 단계를 순차적으로 연결해서 데이터베이스의 구조와 그 안에 데이터를 큰 폭으로 변경이 가능하다.


- 다른 리팩터링과 차이점이 있다면 프로덕션 환경 별로 여러 단계로 나눠서 배포하는 것이 대체로 좋다는 점이다.
이렇게 되면 프로덕션 환경에서 문제가 발생했을 때 되돌리기가 좋다.
  1. 기존 필드와 새 필드를 **동시에 업데이트**
  2. 클라이언트를 **새 필드를 사용**하는 버전으로 조금씩 교체
  3. 중간에 발생하는 버그해결
  4. 기존 필드와 새 필드의 데이터 교체 작업이 끝난다면 예전 필드를 삭제
위의 수정방식이 병렬 수정의 예시이다.

## 2.6 리팩터링, 아케텍처, 애그니(YAGNI)
